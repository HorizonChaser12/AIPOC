<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>autonomous QE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Enhanced chart libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@2.3.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-wordcloud@4.3.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto max-w-4xl mt-8 p-6 bg-white rounded-lg shadow-xl">
        <img src="image.png" alt="Logo" class="w-24 mx-auto mb-4">
        <h1 class="text-3xl font-bold mb-6 text-center text-gray-700">autonomous QE</h1>
        
        <!-- File Upload Section -->
        <div class="mb-8 p-6 border-2 border-dashed border-gray-300 rounded-lg text-center">
            <h2 class="text-xl font-semibold mb-3">Upload Your File to get Insights</h2>
            <p class="text-gray-600 mb-4">Your data stays in your browser and is not uploaded to any server.</p>
            <input type="file" id="fileUpload" accept=".xlsx,.xls" class="hidden" />
            <button id="uploadBtn" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-6 rounded-lg shadow">
                Select File
            </button>
            <p id="fileName" class="mt-2 text-gray-600"></p>
        </div>

        <!-- API Key Input (for LLM integration) -->
        <div id="apiKeySection" class="mb-8 p-6 border border-gray-200 rounded-lg bg-gray-50" style="display: none;">
            <h2 class="text-xl font-semibold mb-3">LLM Integration</h2>
            <p class="text-gray-600 mb-4">Enter your API key to enable AI-powered responses</p>
            <div class="flex gap-2">
                <select id="apiProvider" class="p-2 border rounded">
                    <option value="openai">OpenAI</option>
                    <option value="anthropic">Anthropic</option>
                    <option value="gemini">Gemini</option>
                    <option value="browser">Use Browser LLM (No Key Required)</option>
                </select>
                <input type="password" id="apiKey" placeholder="Enter API Key" class="flex-1 p-2 border rounded" />
                <button id="saveApiKey" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded">Save</button>
            </div>
            <div class="flex items-center mt-2">
                <input type="checkbox" id="rememberKey" class="mr-2" />
                <label for="rememberKey" class="text-sm text-gray-600">Remember in browser storage</label>
            </div>
        </div>
          <!-- Query Section -->
        <div id="querySection" class="mb-8" style="display: none;">
            <div class="mb-6 bg-white p-5 rounded-lg shadow-sm border border-gray-200">
                <label for="queryInput" class="block text-lg font-medium text-gray-700 mb-3">Ask anything about your data:</label>
                <textarea id="queryInput" rows="3" class="w-full p-4 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base" 
                    placeholder="Try questions like:&#10;• What are the top issues reported in February 2025?&#10;• Show me a breakdown of defects by component and create a chart"></textarea>
                <div class="mt-2 text-xs text-gray-500">Pro tip: Include "create a chart" or "visualize" in your query for automatic visualization</div>
            </div>
            
            <button id="submitQuery" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-4 px-4 rounded-lg shadow-md transition duration-150 ease-in-out text-lg">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-1" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                </svg>
                Analyze Data
            </button>
        </div>

        <div id="loader" class="loader"></div>
        
        <!-- Results Area -->
        <div id="resultsArea" class="mt-8" style="display: none;">
            <h2 class="text-2xl font-semibold mb-4 text-gray-700">Results:</h2>
              <div id="response" class="mb-6 p-6 bg-indigo-50 border border-indigo-200 rounded-md shadow-sm">
                <h3 class="text-xl font-semibold text-indigo-700 mb-3 border-b border-indigo-100 pb-2">Generated Response:</h3>
                <p class="text-gray-800 text-base leading-relaxed"></p>
            </div>
            
            <!-- Two-column layout for docs and charts -->
            <div id="resultsPanels" class="flex flex-col md:flex-row md:space-x-4">
                <!-- Documents Panel -->                <div id="retrievedDocs" class="w-full md:w-1/2 p-5 border border-gray-200 rounded-md bg-white shadow-sm">
                    <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2 border-gray-200">Retrieved Documents</h3>
                    <div id="docsContainer" class="max-h-96 overflow-y-auto pr-1"></div>
                </div>
                  <!-- Charts Panel -->                <div id="chartPanel" class="w-full md:w-1/2 p-5 border border-gray-200 rounded-md bg-white mt-4 md:mt-0 shadow-sm">
                    <div class="border-b border-gray-200 mb-5">
                        <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                            <button id="tab-llm" type="button" class="whitespace-nowrap py-3 px-3 border-b-2 font-medium text-sm border-indigo-500 text-indigo-600">
                                LLM Visualization
                            </button>
                            <button id="tab-distribution" type="button" class="whitespace-nowrap py-3 px-3 border-b-2 font-medium text-sm text-gray-600 hover:text-gray-800 hover:border-gray-300">
                                Pattern Analysis
                            </button>
                        </nav>
                    </div><div id="chart-distribution" class="chart-container">
                        <canvas id="distributionChart" height="400"></canvas>
                    </div>
                    <div id="chart-llm" class="chart-container hidden">
                        <canvas id="llmChartCanvas" height="400"></canvas>
                        <div id="llmChartMessage" class="text-center text-gray-500 py-10 mt-4 bg-gray-50 rounded p-4">LLM visualization will appear here.</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="errorArea" class="mt-4 p-4 bg-red-100 border border-red-300 text-red-700 rounded-md" style="display: none;">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM elements
            const fileUpload = document.getElementById('fileUpload');
            const uploadBtn = document.getElementById('uploadBtn');
            const fileName = document.getElementById('fileName');
            const apiKeySection = document.getElementById('apiKeySection');
            const apiKeyInput = document.getElementById('apiKey');
            const apiProvider = document.getElementById('apiProvider');
            const saveApiKeyBtn = document.getElementById('saveApiKey');
            const rememberKeyCheck = document.getElementById('rememberKey');
            const querySection = document.getElementById('querySection');
            const queryInput = document.getElementById('queryInput');
            const submitQuery = document.getElementById('submitQuery');
            const resultsArea = document.getElementById('resultsArea');
            const responseDiv = document.getElementById('response').querySelector('p');
            const retrievedDocsDiv = document.getElementById('retrievedDocs');
            const docsContainer = document.getElementById('docsContainer');
            const chartPanel = document.getElementById('chartPanel');
            const loader = document.getElementById('loader');
            const errorArea = document.getElementById('errorArea');
            
            // Application state
            let excelData = [];
            let searchIndex = null;
            let apiKey = '';
            let apiType = 'openai';
            let chart = null;
            let llmChart = null; // Added for LLM generated chart
            
            // Check for saved API key
            const savedApiKey = localStorage.getItem('api_key');
            const savedApiType = localStorage.getItem('api_type');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
                rememberKeyCheck.checked = true;
                apiKey = savedApiKey;
            }
            if (savedApiType) {
                apiProvider.value = savedApiType;
                apiType = savedApiType;
            }
            
            // File upload handling
            uploadBtn.addEventListener('click', () => {
                fileUpload.click();
            });
            
            fileUpload.addEventListener('change', function(e) {
                if (!e.target.files.length) return;
                
                const file = e.target.files[0];
                fileName.textContent = file.name;
                
                // Show loader
                loader.style.display = 'block';
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const data = event.target.result;
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        
                        // Convert to JSON, ensuring dates are parsed as JS Date objects
                        excelData = XLSX.utils.sheet_to_json(worksheet, { cellDates: true, raw: false });
                        console.log('Excel data loaded (cellDates:true):', excelData.length, 'rows');

                        // Post-process to validate dates and attempt parsing common date strings
                        excelData = excelData.map(row => {
                            for (const key in row) {
                                const value = row[key];
                                if (value instanceof Date) {
                                    if (isNaN(value.getTime())) {
                                        // console.warn(`Invalid Date object for key ${key} in row:`, row);
                                        // Keep it as is; formatContextForLLM will handle it
                                    }
                                } else if (typeof value === 'string') {
                                    // Attempt to parse common date string patterns if cellDates didn't catch it
                                    // This regex is a basic example; more robust parsing might be needed for diverse formats
                                    if (value.match(/^(\d{4}-\d{2}-\d{2}|\d{1,2}[\/-]\d{1,2}[\/-]\d{2,4}|\d{4}[\/-]\d{1,2}[\/-]\d{1,2})$/)) {
                                        const parsedDate = new Date(value);
                                        if (!isNaN(parsedDate.getTime())) {
                                            row[key] = parsedDate;
                                        }
                                    }
                                }
                            }
                            return row;
                        });

                        if (excelData.length > 0) {
                            console.log('First row after all date processing:', excelData[0]);
                        }
                        
                        // Build search index
                        searchIndex = createSearchIndex(excelData);
                        console.log('Search index created');
                        
                        // Create initial data visualization
                        createSummaryChart(excelData);
                        
                        // Show API key input and query sections
                        apiKeySection.style.display = 'block';
                        querySection.style.display = 'block';
                        
                        // Hide loader
                        loader.style.display = 'none';
                        
                        // Display success
                        displayMessage('Data loaded successfully! Enter a query to explore your data.');
                    } catch(error) {
                        console.error('Error processing file:', error);
                        displayError('Error processing file: ' + error.message);
                        loader.style.display = 'none';
                    }
                };
                reader.onerror = function() {
                    displayError('Error reading file');
                    loader.style.display = 'none';
                };
                reader.readAsArrayBuffer(file);
            });
            
            // API key handling
            saveApiKeyBtn.addEventListener('click', () => {
                apiKey = apiKeyInput.value.trim();
                apiType = apiProvider.value;
                
                if (apiType === 'browser') {
                    displayMessage('Using browser-based LLM (limited capabilities but no API key required)');
                } else if (apiKey) {
                    displayMessage('API key saved');
                    if (rememberKeyCheck.checked) {
                        localStorage.setItem('api_key', apiKey);
                        localStorage.setItem('api_type', apiType);
                    } else {
                        localStorage.removeItem('api_key');
                        localStorage.removeItem('api_type');
                    }
                } else {
                    displayError('Please enter an API key or select browser-based LLM');
                    return;
                }
                
                // Focus on query input
                queryInput.focus();
            });
            
            // Query submission
            submitQuery.addEventListener('click', async () => {
                const query = queryInput.value.trim();
                if (!query) {
                    displayError('Please enter a query');
                    return;
                }
                
                if (!excelData.length) {
                    displayError('Please upload an file first');
                    return;
                }
                
                // Clear previous results
                responseDiv.innerHTML = '';
                docsContainer.innerHTML = '';
                errorArea.style.display = 'none';
                document.getElementById('llmChartMessage').textContent = 'LLM visualization will appear here.';
                document.getElementById('llmChartMessage').classList.remove('hidden');
                if (llmChart) {
                    llmChart.destroy();
                    llmChart = null;
                }
                
                // Show loader
                loader.style.display = 'block';
                
                try {
                    // Search for relevant documents
                    const searchResults = search(query, searchIndex);
                    console.log('Search results:', searchResults);
                    
                    // Display retrieved documents
                    displayRetrievedDocs(searchResults);
                    
                    // Create pattern analysis
                    const patterns = analyzePatterns(searchResults);
                    updateChart(patterns);
                    
                    // Format context for LLM
                    const context = formatContextForLLM(excelData);
                    
                    // Generate LLM response
                    let fullLLMResponse;
                    if (apiType === 'browser') {
                        fullLLMResponse = generateBasicResponse(query, searchResults);
                    } else {
                        fullLLMResponse = await generateLLMResponse(query, context);
                    }
                    
                    // Attempt to parse chart data first
                    const chartData = parseLLMChartResponse(fullLLMResponse);
                    
                    // Prepare text for display (remove chart JSON if present)
                    let textForDisplay = fullLLMResponse;
                    if (chartData) {
                        // Remove the matched JSON block from the text to be displayed
                        textForDisplay = fullLLMResponse.replace(/```json\s*[\s\S]*?\s*```/, '').trim();
                    }

                    // Display text response
                    responseDiv.innerHTML = beautifyResponse(textForDisplay);                    // Render LLM chart if data was parsed
                    if (chartData) {
                        renderLLMChart(chartData);
                        // Message will be hidden by renderLLMChart on success
                        
                        // Auto-select the LLM visualization tab when chart is available
                        document.getElementById('tab-llm').click();
                    } else {
                        document.getElementById('llmChartMessage').textContent = 'No chart data provided by LLM or error in parsing.';
                        document.getElementById('llmChartMessage').classList.remove('hidden');
                    }
                    
                    // Identify which docs LLM refers to
                    const referenced = parseReferencedDocs(fullLLMResponse);
                    if (referenced.length) {
                        // Filter results to only those referenced
                        const filtered = searchResults.filter((_, idx) => referenced.includes(idx + 1));
                        displayRetrievedDocs(filtered);
                    }

                    // Show results area
                    resultsArea.style.display = 'block';
                    
                } catch (error) {
                    console.error('Error processing query:', error);
                    displayError(`Error processing query: ${error.message}`);
                } finally {
                    // Hide loader
                    loader.style.display = 'none';
                }
            });
            
            // Search index creation
            function createSearchIndex(documents) {
                // Simple TF-IDF implementation
                const terms = {};
                const docs = [];
                
                documents.forEach((doc, docIndex) => {
                    // Combine all fields into a single text
                    const text = Object.values(doc).join(' ').toLowerCase();
                    const words = text.split(/\W+/).filter(word => word.length > 2);
                    
                    docs.push({
                        id: docIndex,
                        content: doc,
                        terms: {}
                    });
                    
                    // Count term frequency
                    words.forEach(word => {
                        if (!terms[word]) terms[word] = { df: 0, docs: {} };
                        if (!terms[word].docs[docIndex]) {
                            terms[word].docs[docIndex] = 0;
                            terms[word].df++;
                        }
                        terms[word].docs[docIndex]++;
                        docs[docIndex].terms[word] = (docs[docIndex].terms[word] || 0) + 1;
                    });
                });
                
                return { terms, docs, count: documents.length };
            }
            
            // Search function
            function search(query, index) {
                const queryTerms = query.toLowerCase().split(/\W+/).filter(word => word.length > 2);
                const scores = {};
                
                queryTerms.forEach(term => {
                    if (!index.terms[term]) return;
                    
                    const idf = Math.log(index.count / index.terms[term].df);
                    
                    Object.entries(index.terms[term].docs).forEach(([docId, tf]) => {
                        docId = parseInt(docId);
                        scores[docId] = (scores[docId] || 0) + tf * idf;
                    });
                });
                
                // Return top results
                return Object.entries(scores)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10) // Changed from 5 to 10
                    .map(([docId, score]) => ({
                        id: parseInt(docId),
                        content: index.docs[docId].content,
                        score: score
                    }));
            }
            
            // Pattern analysis function
            function analyzePatterns(results) {
                const patterns = {};
                
                // Find columns with categorical data
                const columns = results.length > 0 ? Object.keys(results[0].content) : [];
                
                columns.forEach(column => {
                    const values = {};
                    let uniqueValues = 0;
                    
                    results.forEach(result => {
                        const value = result.content[column];
                        if (value !== undefined && value !== null) {
                            if (!values[value]) {
                                values[value] = 0;
                                uniqueValues++;
                            }
                            values[value]++;
                        }
                    });
                    
                    // Only include columns with a reasonable number of unique values
                    if (uniqueValues > 1 && uniqueValues < 10) {
                        patterns[column] = values;
                    }
                });
                
                return patterns;
            }
            
            // Chart creation
            function createSummaryChart(data) {
                // Find a good column to visualize
                const columnCounts = {};
                
                // Get all columns
                const allColumns = data.length > 0 ? Object.keys(data[0]) : [];
                
                // Count unique values in each column
                allColumns.forEach(column => {
                    const uniqueValues = new Set();
                    data.forEach(row => {
                        if (row[column] !== undefined && row[column] !== null) {
                            uniqueValues.add(row[column]);
                        }
                    });
                    columnCounts[column] = uniqueValues.size;
                });
                
                // Find a good candidate column (not too many unique values)
                let bestColumn = null;
                Object.entries(columnCounts).forEach(([column, count]) => {
                    if (count > 1 && count < 10 && (!bestColumn || count < columnCounts[bestColumn])) {
                        bestColumn = column;
                    }
                });
                
                // If no good column found, use the first one
                if (!bestColumn && allColumns.length > 0) {
                    bestColumn = allColumns[0];
                }
                
                // Create chart with the selected column
                if (bestColumn) {
                    const categories = {};
                    
                    data.forEach(item => {
                        const value = item[bestColumn] || 'Unknown';
                        categories[value] = (categories[value] || 0) + 1;
                    });
                    
                    const ctx = document.getElementById('distributionChart').getContext('2d');
                    
                    chart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: Object.keys(categories),
                            datasets: [{
                                label: `${bestColumn}`,
                                data: Object.values(categories),
                                backgroundColor: 'rgba(99, 102, 241, 0.5)',
                                borderColor: 'rgba(99, 102, 241, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                }
            }
              // Update chart with new data
            function updateChart(patterns) {
                if (!patterns || Object.keys(patterns).length === 0) return;
                
                // Select the first pattern with the most interesting distribution
                const patternKey = Object.keys(patterns)[0];
                const patternValues = patterns[patternKey];
                
                if (chart) {
                    chart.destroy();
                }
                
                // Generate a nice color palette
                const generateColors = (count) => {
                    const colors = [];
                    const backgroundColors = [];
                    const baseColors = [
                        [99, 102, 241],   // indigo
                        [79, 70, 229],    // purple
                        [59, 130, 246],   // blue
                        [16, 185, 129],   // green
                        [245, 158, 11],   // amber
                        [239, 68, 68],    // red
                        [236, 72, 153]    // pink
                    ];
                    
                    for (let i = 0; i < count; i++) {
                        const colorSet = baseColors[i % baseColors.length];
                        backgroundColors.push(`rgba(${colorSet[0]}, ${colorSet[1]}, ${colorSet[2]}, 0.6)`);
                        colors.push(`rgba(${colorSet[0]}, ${colorSet[1]}, ${colorSet[2]}, 1)`);
                    }
                    
                    return { backgrounds: backgroundColors, borders: colors };
                };
                
                const labels = Object.keys(patternValues);
                const colorSets = generateColors(labels.length);
                
                const ctx = document.getElementById('distributionChart').getContext('2d');
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: formatKey(patternKey),
                            data: Object.values(patternValues),
                            backgroundColor: colorSets.backgrounds,
                            borderColor: colorSets.borders,
                            borderWidth: 1,
                            barPercentage: 0.7,
                            borderRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `Distribution of ${formatKey(patternKey)}`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    boxWidth: 12,
                                    usePointStyle: true,
                                    padding: 15
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0,0,0,0.8)',
                                padding: 10,
                                titleFont: { size: 14 },
                                bodyFont: { size: 13 },
                                displayColors: true
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Count',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    precision: 0
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: formatKey(patternKey),
                                    font: {
                                        weight: 'bold'
                                    }
                                }
                            }
                        }
                    }
                });
            }
              // Display retrieved documents
            function displayRetrievedDocs(results) {
                docsContainer.innerHTML = '';
                
                if (results.length === 0) {
                    docsContainer.innerHTML = '<div class="p-6 bg-gray-50 rounded text-center"><p class="text-gray-600">No relevant documents found.</p></div>';
                    return;
                }
                
                results.forEach((result, idx) => {
                    const docCard = document.createElement('div');
                    docCard.className = 'mb-5 p-4 border border-gray-200 rounded-md bg-gray-50 hover:border-indigo-200 transition-all shadow-sm';
                    
                    let contentHTML = `<h4 class="font-semibold text-md text-indigo-700 mb-3 pb-1 border-b border-gray-200">Document #${idx + 1}</h4>`;
                    
                    // Create a table for better data display
                    contentHTML += '<div class="overflow-hidden">';
                    contentHTML += '<table class="min-w-full divide-y divide-gray-200">';
                    contentHTML += '<tbody class="divide-y divide-gray-100">';
                    
                    for (const [key, value] of Object.entries(result.content)) {
                        contentHTML += `
                        <tr>
                            <td class="py-1 px-2 text-sm font-medium text-gray-900">${formatKey(key)}</td>
                            <td class="py-1 px-2 text-sm text-gray-700">${formatValue(value)}</td>
                        </tr>`;
                    }
                    
                    contentHTML += '</tbody></table></div>';
                    contentHTML += `<p class="text-xs text-gray-500 mt-3 pt-2 border-t border-gray-100"><span class="font-medium">Relevance:</span> ${(result.score * 100).toFixed(2)}</p>`;
                    
                    docCard.innerHTML = contentHTML;
                    docsContainer.appendChild(docCard);
                });
            }
              // Format context for LLM
            function formatContextForLLM(dataToFormat) { // Changed parameter name from searchResults to dataToFormat
                if (!dataToFormat || dataToFormat.length === 0) {
                    return '';
                }

                // Convert array of objects to CSV string
                const headers = Object.keys(dataToFormat[0]);
                let csvString = headers.join(',') + '\n';
                
                dataToFormat.forEach(row => {
                    const rowValues = headers.map(header => {
                        let value = row[header];
                        
                        // Format dates consistently as YYYY-MM-DD
                        if (value instanceof Date && !isNaN(value.getTime())) {
                            const year = value.getFullYear();
                            const month = String(value.getMonth() + 1).padStart(2, '0');
                            const day = String(value.getDate()).padStart(2, '0');
                            value = `${year}-${month}-${day}`;
                        }
                        
                        if (typeof value === 'string' && (value.includes(',') || value.includes('\n') || value.includes('"'))) {
                            // Escape quotes and wrap in double quotes if value contains comma, newline, or quote
                            value = '"' + value.replace(/"/g, '""') + '"';
                        }
                        return value;
                    });
                    csvString += rowValues.join(',') + '\n';
                });
                
                return csvString;
            }
              // Generate LLM response using API
            async function generateLLMResponse(query, context) {
                if (!apiKey && apiType !== 'browser') {
                    throw new Error('API key not provided');
                }
                
                let endpoint, payload;
                
                const chartInstruction = `
All dates in the data are formatted as YYYY-MM-DD (ISO format). When processing date-related queries:
1. Interpret natural language date references like "February 2025", "last month", or "next quarter" correctly.
2. For date comparisons, first convert the string dates to proper date objects.
3. When filtering by date ranges, ensure the proper chronological order.

If the query asks for a visualization, or if a chart would be helpful to illustrate the answer, provide a Chart.js compatible JSON object within a markdown code block like this:
\`\`\`json
{
  "type": "bar", // e.g., bar, line, pie, doughnut, radar, polarArea, scatter, bubble
  "data": {
    "labels": ["Label1", "Label2", "Label3"],
    "datasets": [{
      "label": "Dataset Label", // Make this descriptive to explain what the chart is showing
      "data": [10, 20, 30],
      "backgroundColor": ["rgba(255, 99, 132, 0.2)", "rgba(54, 162, 235, 0.2)", "rgba(255, 206, 86, 0.2)"],
      "borderColor": ["rgba(255, 99, 132, 1)", "rgba(54, 162, 235, 1)", "rgba(255, 206, 86, 1)"],
      "borderWidth": 1
    }]
  },
  "options": { 
    "responsive": true,
    "maintainAspectRatio": false,
    "plugins": {
      "title": {
        "display": true,
        "text": "Chart Title Here", // Always include a descriptive title explaining what the chart shows
        "font": { "size": 16 }
      },
      "subtitle": {
        "display": true,
        "text": "Additional explanation about what this visualization represents", // Explain the chart data
        "font": { "size": 14 }
      }
    },
    "scales": {
      "y": {
        "beginAtZero": true,
        "title": {
          "display": true,
          "text": "Y-Axis Label" // Always label your axes
        }
      },
      "x": {
        "title": {
          "display": true,
          "text": "X-Axis Label" // Always label your axes
        }
      }
    }
  }
}
\`\`\`
Ensure the JSON is valid. The chart should be relevant to the query and include clear titles, labels, and explanations.
First, provide the textual answer to the query, then, if applicable, provide the JSON chart data.
`;

                if (apiType === 'openai') {
                    endpoint = 'https://api.openai.com/v1/chat/completions';
                    payload = {
                        model: 'gpt-3.5-turbo', // Consider gpt-4 for better JSON generation if available
                        messages: [
                            {role: 'system', content: `You are a helpful assistant analyzing Excel data. ${chartInstruction}`},
                            {role: 'user', content: `Based on the following data:\\n${context}\\n\\nQuestion: ${query}`}
                        ],
                        temperature: 0.7
                    };
                } else if (apiType === 'anthropic') {
                    endpoint = 'https://api.anthropic.com/v1/messages';
                    payload = {
                        model: 'claude-3-sonnet-20240229', // Or other Claude models
                        messages: [
                            {role: 'user', content: `Based on the following data:\\n${context}\\n\\nQuestion: ${query}\\n\\n${chartInstruction}`}
                        ],
                        max_tokens: 2000 // Increased max_tokens for potentially larger JSON
                    };
                } else if (apiType === 'gemini') {
                    endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                    payload = {
                        contents: [{
                            parts: [{
                                text: `Based on the following data:\\n${context}\\n\\nQuestion: ${query}\\n\\n${chartInstruction}`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.7
                        }
                    };
                } else {
                    return generateBasicResponse(query, context); // No chart for browser-based
                }
                
                const fetchHeaders = {
                    'Content-Type': 'application/json'
                };
                if (apiType !== 'gemini') {
                    fetchHeaders['Authorization'] = `Bearer ${apiKey}`;
                }

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: fetchHeaders,
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                
                // Extract response based on API type
                if (apiType === 'openai') {
                    return data.choices[0].message.content;
                } else if (apiType === 'anthropic') {
                    return data.content[0].text;
                } else if (apiType === 'gemini') {
                    if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                        return data.candidates[0].content.parts[0].text;
                    } else {
                        console.error('Gemini API response error:', data);
                        throw new Error('Invalid response structure from Gemini API');
                    }
                }
                
                return 'Error: Unsupported API type';
            }
            
            // Generate a basic response without LLM
            function generateBasicResponse(query, searchResults) {
                // This is a fallback when no API is available
                const resultCount = searchResults.length;
                document.getElementById('llmChartMessage').textContent = 'Chart generation is not available with browser-based LLM.';
                document.getElementById('llmChartMessage').classList.remove('hidden');
                
                if (resultCount === 0) {
                    return `No results found for "${query}".`;
                }
                
                let response = `Found ${resultCount} relevant documents for "${query}".\n\n`;
                
                // Try to extract key information
                const patterns = analyzePatterns(searchResults);
                if (Object.keys(patterns).length > 0) {
                    response += '**Key Patterns Identified:**\n\n';
                    
                    Object.entries(patterns).forEach(([column, values]) => {
                        response += `* **${formatKey(column)}**: `;
                        const entries = Object.entries(values)
                            .sort((a, b) => b[1] - a[1])
                            .map(([value, count]) => `${value} (${count})`);
                        response += entries.join(', ') + '\n';
                    });
                }
                
                response += '\nThis is a basic analysis. For more sophisticated insights, please provide an API key.';
                
                return response;
            }            // Parse LLM response for chart JSON
            function parseLLMChartResponse(responseText) {
                try {
                    // More flexible regex to capture JSON block
                    const match = responseText.match(/```json\s*([\s\S]*?)\s*```/);
                    if (match && match[1]) {
                        const jsonString = match[1];
                        const chartConfig = JSON.parse(jsonString);
                        // Basic validation
                        if (chartConfig.type && chartConfig.data && chartConfig.data.labels && chartConfig.data.datasets) {
                            return chartConfig;
                        }
                        console.warn("Parsed JSON for chart is missing required fields:", chartConfig);
                        return null;
                    }
                    
                    console.log("No JSON block found in LLM response with ```json ... ``` markers.");
                    return null;
                } catch (error) {
                    console.error("Error parsing chart JSON from LLM response:", error);
                    return null;
                }
            }            // Parse referenced document numbers from LLM response
            function parseReferencedDocs(text) {
                const regex = /Document\s*#(\d+)/g;
                let match;
                const docs = [];
                while ((match = regex.exec(text)) !== null) {
                    docs.push(parseInt(match[1], 10));
                }
                return [...new Set(docs)];
            }

            // Render chart from LLM data
            function renderLLMChart(chartConfig) {
                const llmChartCanvas = document.getElementById('llmChartCanvas');
                if (!llmChartCanvas) {
                    console.error("LLM Chart canvas not found");
                    document.getElementById('llmChartMessage').textContent = 'Error: LLM Chart canvas element not found.';
                    document.getElementById('llmChartMessage').classList.remove('hidden');
                    return;
                }
                const ctx = llmChartCanvas.getContext('2d');
                if (llmChart) {
                    llmChart.destroy();
                }

                try {
                    // Enhance chart configuration with better defaults
                    if (!chartConfig.options) {
                        chartConfig.options = {};
                    }
                    
                    // Ensure responsive and maintainable aspect ratio
                    chartConfig.options.responsive = true;
                    chartConfig.options.maintainAspectRatio = false;
                    
                    // Add plugins for better titles if not provided
                    if (!chartConfig.options.plugins) {
                        chartConfig.options.plugins = {};
                    }
                    
                    // Ensure there's a title
                    if (!chartConfig.options.plugins.title) {
                        chartConfig.options.plugins.title = {
                            display: true,
                            text: 'Data Visualization',
                            font: { size: 18, weight: 'bold' }
                        };
                    }
                    
                    // Add legend configuration if not provided
                    if (!chartConfig.options.plugins.legend) {
                        chartConfig.options.plugins.legend = {
                            display: true,
                            position: 'top',
                            labels: { 
                                boxWidth: 15,
                                padding: 15
                            }
                        };
                    }
                    
                    // Ensure scales have titles
                    if (chartConfig.type === 'bar' || chartConfig.type === 'line') {
                        if (!chartConfig.options.scales) {
                            chartConfig.options.scales = {
                                y: { beginAtZero: true },
                                x: {}
                            };
                        }
                        
                        // Add axis titles if not present
                        if (!chartConfig.options.scales.y.title) {
                            chartConfig.options.scales.y.title = {
                                display: true,
                                text: 'Value'
                            };
                        }
                        
                        if (!chartConfig.options.scales.x.title) {
                            chartConfig.options.scales.x.title = {
                                display: true,
                                text: 'Category'
                            };
                        }
                    }
                    
                    // Create the chart with enhanced config
                    llmChart = new Chart(ctx, chartConfig);
                    document.getElementById('llmChartMessage').classList.add('hidden'); // Hide message on success
                } catch (error) {
                    console.error("Error rendering LLM chart:", error);
                    document.getElementById('llmChartMessage').textContent = `Error rendering LLM chart: ${error.message}`;
                    document.getElementById('llmChartMessage').classList.remove('hidden');
                    if (llmChart) { // Clean up if new Chart failed
                        llmChart.destroy();
                        llmChart = null;
                    }
                }
            }
            
            // Helper functions
            function formatKey(key) {
                return key.split(/(?=[A-Z])/).join(' ');
            }
            
            function formatValue(value) {
                if (value === null || value === undefined) return '';
                if (typeof value === 'string') return value;
                if (typeof value === 'number') return value.toString();
                if (typeof value === 'boolean') return value ? 'Yes' : 'No';
                if (value instanceof Date) return value.toLocaleDateString();
                return JSON.stringify(value);
            }
              function convertMarkdownToHtml(text) {
                if (!text) return '';
                
                // Convert bullet points
                text = text.replace(/^[ ]*\* (.*)$/gm, '<li>$1</li>');
                text = text.replace(/^[ ]*- (.*)$/gm, '<li>$1</li>');
                
                // Convert bold text
                text = text.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-gray-900">$1</strong>');
                
                // Convert italic text
                text = text.replace(/\*(.*?)\*/g, '<em class="italic text-gray-700">$1</em>');

                // Convert headers
                text = text.replace(/^### (.*?)$/gm, '<h3 class="text-lg font-semibold text-gray-800 mt-4 mb-2">$1</h3>');
                text = text.replace(/^## (.*?)$/gm, '<h2 class="text-xl font-bold text-gray-900 mt-5 mb-3">$1</h2>');
                text = text.replace(/^# (.*?)$/gm, '<h1 class="text-2xl font-bold text-indigo-700 mt-6 mb-4">$1</h1>');

                // Handle tables - basic table conversion
                if (text.includes('|')) {
                    const lines = text.split('\n');
                    const tableLines = [];
                    let inTable = false;
                    let tableHTML = '<div class="overflow-x-auto mt-4 mb-4"><table class="min-w-full divide-y divide-gray-300 border border-gray-200">';
                    
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].trim().startsWith('|') && lines[i].trim().endsWith('|')) {
                            if (!inTable) {
                                inTable = true;
                                tableHTML += '<thead class="bg-gray-50"><tr>';
                                
                                // Process header row
                                const headerCells = lines[i].trim().split('|').filter(cell => cell.trim() !== '');
                                headerCells.forEach(cell => {
                                    tableHTML += `<th class="px-3 py-2 text-sm font-medium text-gray-900">${cell.trim()}</th>`;
                                });
                                
                                tableHTML += '</tr></thead><tbody class="divide-y divide-gray-200 bg-white">';
                                i++; // Skip the separator line
                            } else {
                                // Process data rows
                                tableHTML += '<tr>';
                                const cells = lines[i].trim().split('|').filter(cell => cell.trim() !== '');
                                cells.forEach(cell => {
                                    tableHTML += `<td class="px-3 py-2 text-sm text-gray-700">${cell.trim()}</td>`;
                                });
                                tableHTML += '</tr>';
                            }
                            
                            tableLines.push(i);
                        } else if (inTable) {
                            inTable = false;
                            tableHTML += '</tbody></table></div>';
                            text = text.replace(lines.slice(tableLines[0], i).join('\n'), tableHTML);
                            tableLines.length = 0;
                            tableHTML = '<div class="overflow-x-auto mt-4 mb-4"><table class="min-w-full divide-y divide-gray-300 border border-gray-200">';
                        }
                    }
                    
                    if (inTable) {
                        tableHTML += '</tbody></table></div>';
                        text = text.replace(lines.slice(tableLines[0]).join('\n'), tableHTML);
                    }
                }
                
                // Wrap lists in ul tags
                if (text.includes('<li>')) {
                    text = '<ul class="list-disc pl-6 my-4 space-y-1">' + text + '</ul>';
                }
                
                return text;
            }
            
            function beautifyResponse(text) {
                // Special handling for code blocks
                let processedText = text;
                
                // Handle code blocks with language specification (```python, ```javascript, etc.)
                processedText = processedText.replace(/```(\w+)?\n([\s\S]*?)```/g, 
                    '<pre class="bg-gray-800 text-white p-4 rounded-md overflow-x-auto my-4"><code class="language-$1">$2</code></pre>');
                
                // Handle inline code
                processedText = processedText.replace(/`([^`]+)`/g, 
                    '<code class="bg-gray-100 text-indigo-600 px-1 py-0.5 rounded text-sm font-mono">$1</code>');
                
                return processedText.split('\n')
                    .filter(p => p.trim())
                    .map(p => {
                        if (p.startsWith('<h1') || p.startsWith('<h2') || p.startsWith('<h3') || 
                            p.startsWith('<ul') || p.startsWith('<pre') || p.startsWith('<div')) {
                            return convertMarkdownToHtml(p);
                        }
                        return `<p class="mb-4 leading-relaxed text-gray-700">${convertMarkdownToHtml(p)}</p>`;
                    })
                    .join('');
            }
            
            function displayError(message) {
                errorArea.textContent = message;
                errorArea.style.display = 'block';
                loader.style.display = 'none';
            }
            
            function displayMessage(message) {
                responseDiv.innerHTML = `<p class="mb-3">${message}</p>`;
                resultsArea.style.display = 'block';
                loader.style.display = 'none';
            }
              // Tab navigation for charts
            const tabs = document.querySelectorAll('#chartPanel button');
            const chartContainers = document.querySelectorAll('.chart-container');
            
            // Initialize LLM tab as default
            document.getElementById('chart-distribution').classList.add('hidden');
            document.getElementById('chart-llm').classList.remove('hidden');
            document.getElementById('tab-distribution').classList.remove('border-indigo-500', 'text-indigo-600', 'font-medium');
            document.getElementById('tab-distribution').classList.add('text-gray-600', 'hover:text-gray-800', 'hover:border-gray-300');
            document.getElementById('tab-llm').classList.add('border-indigo-500', 'text-indigo-600', 'font-medium');
            document.getElementById('tab-llm').classList.remove('text-gray-600', 'hover:text-gray-800', 'hover:border-gray-300');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const target = tab.id.split('-')[1];
                    
                    // Hide all chart containers
                    chartContainers.forEach(container => {
                        container.classList.add('hidden');
                    });
                    
                    // Remove active class from all tabs
                    tabs.forEach(t => {
                        t.classList.remove('border-indigo-500', 'text-indigo-600', 'font-medium');
                        t.classList.add('text-gray-600', 'hover:text-gray-800', 'hover:border-gray-300'); // Consistent hover
                    });
                    
                    // Show the selected chart container
                    const targetChartContainer = document.getElementById(`chart-${target}`);
                    if (targetChartContainer) {
                        targetChartContainer.classList.remove('hidden');
                    }
                    
                    // Add active class to the selected tab
                    tab.classList.add('border-indigo-500', 'text-indigo-600', 'font-medium');
                    tab.classList.remove('text-gray-600', 'hover:text-gray-800', 'hover:border-gray-300');
                });
            });
        });
    </script>
</body>
</html>
